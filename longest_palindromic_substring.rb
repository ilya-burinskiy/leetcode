# Time Limit Exceeded
# s =
# "321012321001232100123210012321001232100123210012321001232100123210012321" \
# "001232100123210012321001232100123210012321001232100123210012321001232100" \
# "123210012321001232100123210012321001232100123210012321001232100123210012" \
# "321001232100123210012321001232100123210012321001232100123210012321001232" \
# "100123210012321001232100123210012321001232100123210012321001232100123210" \
# "0123210012321001232100123210012321001232100123210012321001232100123210012321001" \
# "2321001232100123210012321001232100123210012321001232100123210012321001232100123" \
# "2100123210012321001232100123210012321001232100123210012321001232100123210012321" \
# "0012321001232100123210012321001232100123210012321001232100123210012321001232100" \
# "1232100123210012321001232100123210012321001232100123210012321001232100123210012" \
# "3210012321001232100123210012321001232100123210012321001232100123210012321001232" \
# "1001232100123210012321001232100123210012321001232100123210012321001232100123210" \
# "01232100123210012321001232100123210012321001232100123210123210012321001232100123210123"
def longest_palindrome(s)
  table = Array.new(s.length) { Array.new(s.length, true) }

  l = r = 0
  (s.length - 2).downto(0).each do |i|
    (s.length - 1).downto(i + 1).each do |j|
      table[i][j] = s[i] == s[j] && table[i + 1][j - 1]
      l, r = i, j if table[i][j] && j - i > r - l
    end
  end

  s[l..r]
end
